<?php

/**
 | DataSet.php.
 |
 | This class is designed to be used along with the parseCode()
 | and parseFile() functions (see ../include/parse.php).
 |
 | The class provides an interface for creating and maintaining
 | datasets (namespaces), allowing for variable setting/expansion.
 */

define("DATASET_OK", 0);

define("DATASET_SET_EXISTS", -1);
define("DATASET_UNKNOWN_SET", -2);
define("DATASET_UNKNOWN_KEY", -4);

class DataSets {
	public	$ds;		/* Array of dataset names. */
	
	public	$keys;		/* 2D key/value arrays. */
	public	$vals;
	
	public	$attr;		/* Array - one entry per dataset, can be
				 | jsGlobal (export to JavaScript, declared
				 | as associative arrays) or jsLocal (export to
				 | localStorage()).
				 */
	
	public	$currSet;	/* Current working dataset ID. */
	
	/**
	 | These are generated by the export() method. Basically, they
	 | are populated by strings of JavaScript code which can be
	 | applied to set a dataset as either JavaScript globals,
	 | localStorage(), or both.
	 */
	public	$exportGlobal;
	public	$exportLocal;
	
	function __construct() {
		$this->ds = array();
		
		$this->keys = array();
		$this->vals = array();
		$this->attr = array();
		
		/**
		 | Initialise the default dataset.
		 */
		$this->newSet("storage");
		$this->currSet = 0;
	}
	
	/**
	 | Create a new dataset.
	 */
	function newSet($ds) {
		if (in_array($ds, $this->ds))
			return DATASET_SET_EXISTS;
		
		array_push($this->ds, $ds);
		
		array_push($this->keys, array());
		array_push($this->vals, array());
		
		/**
		 | Nothing will be exported by default.
		 */
		array_push($this->attr, "");
		
		return DATASET_OK;
	}
	
	/**
	 | Returns the ID of the specified set, or DATASET_UNKNOWN_SET
	 | if the specified set does not exist.
	 */
	function lookupSet($ds) {
		for ($intSet = 0; $intSet < count($this->ds); $intSet++) {
			if ($ds == $this->ds[$intSet])
				return $intSet;
		}
		
		return DATASET_UNKNOWN_SET;
	}
	
	/**
	 | Returns the ID of the specified key in the given set.
	 |
	 | If the specified dataset ($ds) is empty, will look for the key
	 | in the current set ($this->currSet).
	 */
	function lookupKey(&$ds, $k) {
		if ($ds != NULL && ! empty(trim($ds))) {
			$dsID = $this->lookupSet($ds);
			if ($dsID < 0)
				return $dsID;
			$ds = $dsID;
		}
		else {
			$ds = $this->currSet;
			$dsID = $ds;
		}
		
		for ($keyID = 0; $keyID < count($this->keys[$dsID]); $keyID++) {
			if ($k == $this->keys[$dsID][$keyID])
				return $keyID;
		}
		
		return DATASET_UNKNOWN_KEY;
	}
	
	/**
	 | Look up a particular value by key reference - again, if the
	 | specified dadaset ($ds) is empty, will look in the current
	 | ($this->currSet) set.
	 */
	function lookupVal(&$ds, $k) {
		if ($ds != NULL && ! empty(trim($ds))) {
			$dsID = $this->lookupSet($ds);
			if ($dsID < 0)
				return $dsID;
			$ds = $dsID;
		}
		else {
			$ds = $this->currSet;
			$dsID = $ds;
		}
		
		for ($valID = 0; $valID < count($this->keys[$dsID]); $valID++) {
			if ($k == $this->keys[$dsID][$valID])
				return $this->vals[$dsID][$valID];
		}
		
		return DATASET_UNKNOWN_KEY;
	}
	
	/**
	 | Set a value.
	 */
	function setVal(&$ds, $k, $v) {
		if ($ds != NULL && ! empty(trim($ds))) {
			$dsID = $this->lookupSet($ds);
			if ($dsID < 0)
				return $dsID;
			$ds = $dsID;
		}
		else {
			$ds = $this->currSet;
			$dsID = $ds;
		}
		
		$keyID = $this->lookupKey($ds, $k);
		
		if ($keyID < DATASET_OK) {
			array_push($this->keys[$dsID], $k);
			array_push($this->vals[$dsID], $v);
		}
		else
			$this->vals[$dsID][$keyID] = $v;
		
		return $keyID;
	}
	
	/**
	 | Contstructs the exportGlobal and exportLocal output
	 | strings.
	 */
	function export() {
		$this->exportGlobal = "\t\t<script type=\"text/javascript\">\n";
		$this->exportLocal = "\t\t<script type=\"text/javascript\">\n";
		
		for ($intSet = 0; $intSet < count($this->ds); $intSet++) {
			$strSpace = $this->attr[$intSet];
			
			if (empty($strSpace))
				continue;
			
			if ($strSpace == "both" || $strSpace == "jsGlobal") {
				$this->exportGlobal .=
"\t\t\t/********************************************************************
\t\t\t | Exporting global dataset '" . $this->ds[$intSet] . "'
\t\t\t */

\t\t\tvar\t" . $this->ds[$intSet] . " = [];

";
			}
			
			if ($strSpace == "both" || $strSpace == "jsLocal") {
				$this->exportLocal .=
"\t\t\t/********************************************************************
\t\t\t | Exporting local dataset '" . $this->ds[$intSet] . "'
\t\t\t */

";
			}
			
			for ($intKey = 0; $intKey < count($this->keys[$intSet]); $intKey++) {
				if ($strSpace == "both" || $strSpace == "jsGlobal")
				$this->exportGlobal .= "\t\t\t" . $this->ds[$intSet] . "['" . $this->keys[$intSet][$intKey] . "'] = \"" . $this->vals[$intSet][$intKey] . "\";\n";
				if ($strSpace == "both" || $strSpace == "jsLocal")
					$this->exportLocal .= "\t\t\tlocalStorage.setItem(\"" . $this->ds[$intSet] . $this->keys[$intSet][$intKey] . "\", \"" . $this->vals[$intSet][$intKey] . "\");\n";
			}
			
			if ($strSpace == "both" || $strSpace == "jsGlobal") {
				$this->exportGlobal .=
"\t\t\t/**
\t\t\t | Exported global dataset '" . $this->ds[$intSet] . "'    -- DONE --
\t\t\t ********************************************************************/

";
			}
			
			if ($strSpace == "both" || $strSpace == "jsLocal") {
				$this->exportLocal .=
"\t\t\t/**
\t\t\t | Exported local dataset '" . $this->ds[$intSet] . "'    -- DONE --
\t\t\t ********************************************************************/

";
			}
			
		}
		
		$this->exportGlobal .= "\t\t</script>\n\n";
		$this->exportLocal .= "\t\t</script>\n\n";
	}
}
